<!DOCTYPE html>
<html>
<head>
    <title>Building a Diagnostic Tool for my Car</title>
</head>
<body>
    <h1>Building a Diagnostic Tool for my Car with Python!</h1>
    <h2>Table of Contents</h2>
    <ul>
        <li><a href="#intro">Introduction</a></li>
        <li><a href="#connecting">Connecting to the CAN Network</a></li>
        <li><a href="#socketcan">Writing a Python Wrapper for SocketCAN</a></li>
        <li><a href="#protocols">Writing Higher Level Protocols</a></li>
    </ul>

    <section id="intro">
    <h2>Introduction</h2>
        <p>The days of cars being pure mechanical devices are long gone but we still tend to overlook the amount of electrical components that must communicate with each other and how they do it inside a vehicle. In the past, car ECUs relied primarily on complex point-to-point wiring. In 1986, The company BOSCH developed the CAN protocol as a solution and it was adopted as an international standard in 1993 (ISO 11898). The CAN protocol standardized the physical and data link layer; most cars use that protocol today in order to get fast and robust communication between modules. In 2008 ISO 15765 was adopted in the US as the mandatory Protocol for the OBD2 self-diagnostic system, primarily ISO 15765-4 which seeks to standardize the CAN bus interface for external test equipment. In this project I will be tapping into my truck's OBD2 port, decoding CAN traffic, and writing custom python code to interface with the OBD2.</p>
    </section>

    <section id="connecting">
    <h2>Connecting to the CAN Network</h2>
    <p>The vehicle I will be working with is my daily driver, a 2015 Dodge Ram 1500. Most cars, including my truck, have two can busses: A medium speed (MS) can network for diagnostics and a high speed (HS) network for more critical processes. On my truck these are called CAN-IHS and CAN-C respectively. Below are the schematics for my truck's CAN networks.</p>
    <embed src="images/CAN_C_RAM.pdf" width="800" height="600" type="application/pdf">
    <embed src="images/CAN-C-BUS-SYSTEM.pdf" width="800" height="600" type="application/pdf">
    <embed src="images/CAN_IHS_RAM.pdf" width="800" height="600" type="application/pdf">
    <embed src="images/CAN-IHS-BUS-SYSTEM.pdf" width="800" height="600" type="application/pdf">
    <p>As mentioned earlier, due to the introduction of ISO 15765-4 the OBD2 port on my truck has access to the CAN-C network through pins 6 (CAN high) and 14 (CAN low).</p>
    <img src="images/obd2-connector-pinout-socket.svg" alt="SVG Image" width="800" height="600">
    <p>*A quick aside on the CAN physical layer (ISO 11898-2): generally the can bus consists of a differential signal sent through a twisted pair of wires reffered to as CAN high and CAN low. For the scope of this project that is all we reallly need to know, but I recommend finding more resources online.</p>
    <p>Knowing the above I will be using the following hardware to establish a connection:</p>
    <ul>
        <li>A linux computer with <a href="https://www.kernel.org/doc/html/latest/networking/can.html">socket-can</a> and <a href="https://github.com/linux-can/can-utils">can-utils</a></li>
        <li><a href="https://www.adafruit.com/product/4841?gclid=Cj0KCQjwy4KqBhD0ARIsAEbCt6hQvV-kPt_Ral_f11UuzZz2_lTsW4SAJDilZumwbzQRJ-uC7dVlL7MaAsJGEALw_wcB">An OBD2 to DB9 cable</a></li>
        <img src="images/IMG_0415.jpg" alt="Peak Adapter" width="300" height="400">
        <li><a href="https://www.gridconnect.com/products/can-usb-adapter-pcan-usb?variant=8999285751844&utm_term=&utm_campaign=Shopping+-+Product&utm_source=adwords&utm_medium=ppc&hsa_acc=7986939350&hsa_cam=18566303751&hsa_grp=149294111698&hsa_ad=655600308401&hsa_src=g&hsa_tgt=pla-484991577302&hsa_kw=&hsa_mt=&hsa_net=adwords&hsa_ver=3&gad=1&gclid=Cj0KCQjwy4KqBhD0ARIsAEbCt6gIqeXJRzU6gAuBXw06eHSQTkY2k1A5csFtdDeAOix8PGlBZyVzmTMaAnhGEALw_wcB">A Grid Connect Peak-USB adapter</a></li>
        <img src="images/IMG_0416.jpg" alt="OBD2 cable" width="300" height="400">
    </ul>
    <p>With these three pieces of hardware connected, I can now look at some of the raw trafiic getting sent over the CAN network.</p>
    <h3>Setting up Linux to Interact with the CAN Network</h3>
    <p>Linux is able to leverage it's networking stack through SocketCAN and a few common device drivers to treat a connection to a CAN Network as similar as possible to a TCP/IP connections. This allows programmers to easily learn how to use the CAN sockets much alike other network programming. The aformentioned peak has device drivers that come installed by default on a generic Linux install. When you first plug in the peak into your computer it will be recognized as a network device and you can configure the interface using the <code>ip</code> command. Running the <code>ip a</code> command with the peak connected shows the following:</p>
    <img src="images/can0_if_ipa.png" alt="can0">
    <p>At this point we can bring up our network with:</p>
    <code>sudo ip link set can0 up type can bitrate 500000 restart-ms 100 listen-only on</code>
    <p>The bitrate specified will depend on the baud-rate of your car's CAN network. In my case I found it out by trial and error. Some common values to try are 125000, 250000, 500000, and 1000000. It is important to pass in the listen-only option when trying out different bitrates so that we don't accidently cause errors on the CAN bus. You know you have found the correct bitrate when you can run the <code>candump</code> command and see raw CAN traffic being printed to your stdout:</p>
    <img src="images/candump.png" alt="candump image">
    <p>For convenience, I captured a log file containing a few minutes of data using the <code>candump -l</code> command. This log file will come in useful later on as we can set up a virtual can interface and replay the recorded CAN data to emulate a live CAN network.</p>
    </section>

    <section id="socketcan">
    <h2>Writing a Python Wrapper for SocketCAN</h2>
    <p>In order to develop my own diagnostic tool, I will need a way to interact with the CAN interface I brought up. I decided to use the ctypes module in python to directly convert some of the frame structures defined in socketCAN into python objects. I took this approach as it will later on allow me to leverage a lot of the cool libraries python has accessible for plotting and creating command line interface tools.</p>
    <figure id="CanFrame">
    <img src="images/canframe_structure.png" alt="canframe">
    <figcaption>An example of a python wrapper class for a SocketCAN definition using the ctypes module.</figcaption>
    </figure>
    <p>Once I converted some of the basic C definitions from python I created a class that inherits from the socket Python class. The idea here is that I can create methods defining exactly how I want to write, read, bind, filter, and perform other operations based off of the CAN addresses and structure definitons I previously created. Through this approach I can also use the fileno() property of the socket class to grab the file descriptor of the socket and eventually pass it in to the asyncio.Transport class to leverage the event loop and be able to add callback methods that fire once data is available to read on the interface.</p>
    <figure id="write">
    <img src="images/write.png" alt="write canframe">
    <figcaption>Method I added to SocketCAN class that allows you to write a CAN frame to the socket.</figcaption>
    </figure>
    <figure id="read">
    <img src="images/read.png" alt="read canframe">
    <figcaption>Method I added to SocketCAN class that allows you to read a CAN frame from the socket and return an object.</figcaption>
    </figure>
    <p>With the SocketCAN wrapper completed I can now begin focusing on writing the transport class as well as some higher level protocols.</p>
    </section>
    <section id="protocols">
    <h2>Writing Higher Level Protocols</h2>
    <p>With the low level stuff out of the way the next step is to define some higher level rules on what how to work with the CAN network. In networking transports and protocols have a 1-to-1 relationship and I will need to define both in this project. Luckily for me asyncio has both a base Transport and a base Protocol class which I can inherit from and build upon. Knowing this I created a CANPort class and a base CANProtocol class that I will use as the basis of even higher level protocols.</p>
    <figure id="transport">
    <img src="images/CANPort.png" alt="can transport">
    <figcaption>Class I created to define the CAN transport.</figcaption>
    </figure>
    <figure id="protocol">
    <img src="images/CANprotocol.png" alt="can protocol">
    <figcaption>Base Class I created to build CAN protocols off of.</figcaption>
    </figure>
    <p>Additionally I added a CANPortCollection class to help manange multiple transports for convenience. With these classes fleshed out I created a very simple class called FrameConsumer to test my work up until this point. The FrameConsumer at this point will fire a callback that prints whenever a frame is recieved on the network. For the sake of iteration time and safety, I brought up a virtual CAN network to test on (vcan0). I can use this vcan0 network and the can-utils tools to emulate real traffic on a bus.
    <figure id="frameconsumer">
    <img src="images/run_frame_consumer.png" alt="script to start frame consumer">
    <figcaption>Simple script I wrote to start a frame consumer on vcan0, In this case I am filtering for frames with the 0x1d0 cob-id.</figcaption>
    </figure>
    <figure id="cansend">
    <img src="images/cansend.png" alt="cansedn frame">
    <figcaption>Here I am using the cansend command to send a frame over the virtual can network while the FrameConsumer is listening.</figcaption>
    </figure>
    <figure id="output">
    <img src="images/terminaloutput.png" alt="terminal output of frameconsumer">
    <figcaption>This is the output from the script above. When the frame was sent with the cansend command the FrameConsumer fired a callback to print the frame information.</figcaption>
    </figure>
    <p>With the ability to filter specific cobids and fire callbacks when messages are recieved. I can now easily send and monitor for diagnostic messages, specifically 0x7DF(Request) and 0x7E8(Response). This <a href="https://www.csselectronics.com/pages/obd2-pid-table-on-board-diagnostics-j1979">OBD2 PID Table</a> provides a lookup table for all the PIDs that are standard to the OBD2 protocol. An example usage of this module would be to send out requests for vehicle speed at a certain interval and live plot the responses on a custom dashboard.</p>
    </section>
    <section id="conclusion">
        <h2>Conclusion</h2>
        <p>Through this project, I have successfully built a module for a car using Python and SocketCAN. I have learned how to connect to the CAN network, write a Python wrapper for SocketCAN, and write higher level protocols. In the future I can take this module and create custom GUI's and visualizations using Pythons extensive libraries.</p>
    </section>
</body>
</html>