<!DOCTYPE html>
<html>
<head>
    <title>Building a Diagnostic Tool for my Car</title>
</head>
<body>
    <h1>Building a Diagnostic Tool for my Car</h1>
    <h2>Table of Contents</h2>
    <ul>
        <li><a href="#intro">Introduction</a></li>
        <li><a href="#connecting">Connecting to the CAN Network</a></li>
        <li><a href="#socketcan">Writing a Python Wrapper for SocketCAN</a></li>
    </ul>

    <section id="intro">
    <h2>Introduction</h2>
        <p>The days of cars being pure mechanical devices are long gone but we still tend to overlook the amount of electrical components that must communicate with each other and how they do it inside a vehicle. In the past, car ECUs relied primarily on complex point-to-point wiring. In 1986, The company BOSCH developed the CAN protocol as a solution and it was adopted as an international standard in 1993 (ISO 11898). The CAN protocol standardized the physical and data link layer; most cars use that protocol today in order to get fast and robust communication between modules. In 2008 ISO 15765 was adopted in the US as the mandatory Protocol for the OBD2 self-diagnostic system, primarily ISO 15765-4 which seeks to standardize the CAN bus interface for external test equipment. In this project I will be tapping into my truck's OBD2 port, decoding CAN traffic, and writing custom python code to interface with the OBD2.</p>
    </section>

    <section id="connecting">
    <h2>Connecting to the CAN Network</h2>
    <p>The vehicle I will be working with is my daily driver, a 2015 Dodge Ram 1500. Most cars, including my truck, have two can busses: A medium speed (MS) can network for diagnostics and a high speed (HS) network for more critical processes. On my truck these are called CAN-IHS and CAN-C respectively. Below are the schematics for my truck's CAN networks.</p>
    <embed src="images/CAN_C_RAM.pdf" width="800" height="600" type="application/pdf">
    <embed src="images/CAN-C-BUS-SYSTEM.pdf" width="800" height="600" type="application/pdf">
    <embed src="images/CAN_IHS_RAM.pdf" width="800" height="600" type="application/pdf">
    <embed src="images/CAN-IHS-BUS-SYSTEM.pdf" width="800" height="600" type="application/pdf">
    <p>As mentioned earlier, due to the introduction of ISO 15765-4 the OBD2 port on my truck has access to the CAN-C network through pins 6 (CAN high) and 14 (CAN low).</p>
    <img src="images/obd2-connector-pinout-socket.svg" alt="SVG Image" width="800" height="600">
    <p>*A quick aside on the CAN physical layer (ISO 11898-2): generally the can bus consists of a differential signal sent through a twisted pair of wires reffered to as CAN high and CAN low. For the scope of this project that is all we reallly need to know, but I recommend finding more resources online.</p>
    <p>Knowing the above I will be using the following hardware to establish a connection:</p>
    <ul>
        <li>A linux computer with <a href="https://www.kernel.org/doc/html/latest/networking/can.html">socket-can</a> and <a href="https://github.com/linux-can/can-utils">can-utils</a></li>
        <li><a href="https://www.adafruit.com/product/4841?gclid=Cj0KCQjwy4KqBhD0ARIsAEbCt6hQvV-kPt_Ral_f11UuzZz2_lTsW4SAJDilZumwbzQRJ-uC7dVlL7MaAsJGEALw_wcB">An OBD2 to DB9 cable</a></li>
        <img src="images/IMG_0415.jpg" alt="Peak Adapter" width="300" height="400">
        <li><a href="https://www.gridconnect.com/products/can-usb-adapter-pcan-usb?variant=8999285751844&utm_term=&utm_campaign=Shopping+-+Product&utm_source=adwords&utm_medium=ppc&hsa_acc=7986939350&hsa_cam=18566303751&hsa_grp=149294111698&hsa_ad=655600308401&hsa_src=g&hsa_tgt=pla-484991577302&hsa_kw=&hsa_mt=&hsa_net=adwords&hsa_ver=3&gad=1&gclid=Cj0KCQjwy4KqBhD0ARIsAEbCt6gIqeXJRzU6gAuBXw06eHSQTkY2k1A5csFtdDeAOix8PGlBZyVzmTMaAnhGEALw_wcB">A Grid Connect Peak-USB adapter</a></li>
        <img src="images/IMG_0416.jpg" alt="OBD2 cable" width="300" height="400">
    </ul>
    <p>With these three pieces of hardware connected, I can now look at some of the raw trafiic getting sent over the CAN network.</p>
    <h3>Setting up Linux to Interact with the CAN Network</h3>
    <p>Linux is able to leverage it's networking stack through SocketCAN and a few common device drivers to treat a connection to a CAN Network as similar as possible to a TCP/IP connections. This allows programmers to easily learn how to use the CAN sockets much alike other network programming. The aformentioned peak has device drivers that come installed by default on a generic Linux install. When you first plug in the peak into your computer it will be recognized as a network device and you can configure the interface using the <code>ip</code> command. Running the <code>ip a</code> command with the peak connected shows the following:</p>
    <img src="images/can0_if_ipa.png" alt="can0">
    <p>At this point we can bring up our network with:</p>
    <code>sudo ip link set can0 up type can bitrate 500000 restart-ms 100 listen-only on</code>
    <p>The bitrate specified will depend on the baud-rate of your car's CAN network. In my case I found it out by trial and error. Some common values to try are 125000, 250000, 500000, and 1000000. It is important to pass in the listen-only option when trying out different bitrates so that we don't accidently cause errors on the CAN bus. You know you have found the correct bitrate when you can run the <code>candump</code> command and see raw CAN traffic being printed to your stdout:</p>
    <img src="images/candump.png" alt="candump image">
    <p>For convenience, I captured a log file containing a few minutes of data using the <code>candump -l</code> command. This log file will come in useful later on as we can set up a virtual can interface and replay the recorded CAN data to emulate a live CAN network.</p>
    </section>

    <section id="socketcan">
    <h2>Writing a Python Wrapper for SocketCAN</h2>
    <p>In order to develop my own diagnostic tool, I will need a way to interact with the CAN interface I brought up. I decided to use the ctypes module in python to directly convert some of the frame structures defined in socketCAN into python objects. I took this approach as it will later on allow me to leverage a lot of the cool libraries python has accessible for plotting and creating command line interface tools.</p>
    <figure id="CanFrame">
    <img src="images/canframe_structure.png" alt="canframe">
    <figcaption>An example of a python wrapper class for a SocketCAN definition using the ctypes module.</figcaption>
    </figure>
    <p>Once I converted some of the basic C definitions from python I created a class that inherits from the socket Python class. The idea here is that I can create methods defining exactly how I want to write, read, bind, filter, and perform other operations based off of the CAN addresses and structure definitons I previously created. Through this approach I can also use the fileno() property of the socket class to grab the file descriptor of the socket and eventually pass it in to the asyncio.Transport class to leverage the event loop and be able to add callback methods that fire once data is available to read on the interface.</p>
    <figure id="write">
    <img src="images/write.png" alt="write canframe">
    <figcaption>Method I added to SocketCAN class that allows you to write a CAN frame to the socket.</figcaption>
    </figure>
    <figure id="read">
    <img src="images/read.png" alt="read canframe">
    <figcaption>Method I added to SocketCAN class that allows you to read a CAN frame from the socket and return an object.</figcaption>
    </figure>
    </section>

</body>
</html>